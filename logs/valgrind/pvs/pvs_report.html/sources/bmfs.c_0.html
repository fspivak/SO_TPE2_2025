<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>bmfs.c</title>
  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.5.1.min.js"></script>
</head>
<body>
<pre><code class = "cpp">
<a name="ln1">// This is a personal academic project. Dear PVS-Studio, please check it.</a>
<a name="ln2">// PVS-Studio Static Code Analyzer for C, C++, C#, and Java: https://pvs-studio.com</a>
<a name="ln3"> </a>
<a name="ln4"> </a>
<a name="ln5">/* BareMetal File System Utility */</a>
<a name="ln6">/* Written by Ian Seyler of Return Infinity */</a>
<a name="ln7"> </a>
<a name="ln8">/* Global includes */</a>
<a name="ln9">#include &lt;stdio.h&gt;</a>
<a name="ln10">#include &lt;stdlib.h&gt;</a>
<a name="ln11">#include &lt;string.h&gt;</a>
<a name="ln12">#include &lt;strings.h&gt;</a>
<a name="ln13">#include &lt;ctype.h&gt;</a>
<a name="ln14"> </a>
<a name="ln15">/* Global defines */</a>
<a name="ln16">struct BMFSEntry</a>
<a name="ln17">{</a>
<a name="ln18">	char FileName[32];</a>
<a name="ln19">	unsigned long long StartingBlock;</a>
<a name="ln20">	unsigned long long ReservedBlocks;</a>
<a name="ln21">	unsigned long long FileSize;</a>
<a name="ln22">	unsigned long long Unused;</a>
<a name="ln23">};</a>
<a name="ln24"> </a>
<a name="ln25">/* Global constants */</a>
<a name="ln26">// Min disk size is 6MiB (three blocks of 2MiB each.)</a>
<a name="ln27">const unsigned long long minimumDiskSize = (6 * 1024 * 1024);</a>
<a name="ln28"> </a>
<a name="ln29">/* Global variables */</a>
<a name="ln30">FILE *file, *disk;</a>
<a name="ln31">unsigned int filesize, disksize;</a>
<a name="ln32">char tempfilename[32], tempstring[32];</a>
<a name="ln33">char *filename, *diskname, *command;</a>
<a name="ln34">char fs_tag[] = &quot;BMFS&quot;;</a>
<a name="ln35">char s_list[] = &quot;list&quot;;</a>
<a name="ln36">char s_format[] = &quot;format&quot;;</a>
<a name="ln37">char s_initialize[] = &quot;initialize&quot;;</a>
<a name="ln38">char s_create[] = &quot;create&quot;;</a>
<a name="ln39">char s_read[] = &quot;read&quot;;</a>
<a name="ln40">char s_write[] = &quot;write&quot;;</a>
<a name="ln41">char s_delete[] = &quot;delete&quot;;</a>
<a name="ln42">struct BMFSEntry entry;</a>
<a name="ln43">void *pentry = &amp;entry;</a>
<a name="ln44">char *BlockMap;</a>
<a name="ln45">char *FileBlocks;</a>
<a name="ln46">char Directory[4096];</a>
<a name="ln47">char DiskInfo[512];</a>
<a name="ln48"> </a>
<a name="ln49">/* Built-in functions */</a>
<a name="ln50">int findfile(char *filename, struct BMFSEntry *fileentry, int *entrynumber);</a>
<a name="ln51">void list();</a>
<a name="ln52">void format();</a>
<a name="ln53">int initialize(char *diskname, char *size, char *mbr, char *boot, char *kernel);</a>
<a name="ln54">void create(char *filename, unsigned long long maxsize);</a>
<a name="ln55">void read(char *filename);</a>
<a name="ln56">void write(char *filename);</a>
<a name="ln57">void delete(char *filename);</a>
<a name="ln58"> </a>
<a name="ln59">/* Program code */</a>
<a name="ln60">int main(int argc, char *argv[])</a>
<a name="ln61">{</a>
<a name="ln62">	/* Parse arguments */</a>
<a name="ln63">	if (argc &lt; 3)</a>
<a name="ln64">	{</a>
<a name="ln65">		printf(&quot;BareMetal File System Utility v1.0 (2013 04 10)\n&quot;);</a>
<a name="ln66">		printf(&quot;Written by Ian Seyler @ Return Infinity (ian.seyler@returninfinity.com)\n\n&quot;);</a>
<a name="ln67">		printf(&quot;Usage: %s disk function file\n&quot;, argv[0]);</a>
<a name="ln68">		printf(&quot;Disk: the name of the disk file\n&quot;);</a>
<a name="ln69">		printf(&quot;Function: list, read, write, create, delete, format, initialize\n&quot;);</a>
<a name="ln70">		printf(&quot;File: (if applicable)\n&quot;);</a>
<a name="ln71">		exit(0);</a>
<a name="ln72">	}</a>
<a name="ln73"> </a>
<a name="ln74">	diskname = argv[1];</a>
<a name="ln75">	command = argv[2];</a>
<a name="ln76">	filename = argv[3];</a>
<a name="ln77"> </a>
<a name="ln78">	if (strcasecmp(s_initialize, command) == 0)</a>
<a name="ln79">	{</a>
<a name="ln80">		if (argc &gt;= 4)</a>
<a name="ln81">		{</a>
<a name="ln82">			char *size = argv[3];  // Required</a>
<a name="ln83">			char *mbr = (argc &gt; 4 ? argv[4] : NULL);    // Opt.</a>
<a name="ln84">			char *boot = (argc &gt; 5 ? argv[5] : NULL);   // Opt.</a>
<a name="ln85">			char *kernel = (argc &gt; 6 ? argv[6] : NULL); // Opt.</a>
<a name="ln86">			int ret = initialize(diskname, size, mbr, boot, kernel);</a>
<a name="ln87">			exit(ret);</a>
<a name="ln88">		}</a>
<a name="ln89">		else</a>
<a name="ln90">		{</a>
<a name="ln91">			printf(&quot;Usage: %s disk %s &quot;, argv[0], command);</a>
<a name="ln92">			printf(&quot;size [mbr_file] &quot;);</a>
<a name="ln93">			printf(&quot;[bootloader_file] [kernel_file]\n&quot;);</a>
<a name="ln94">			exit(1);</a>
<a name="ln95">		}</a>
<a name="ln96">	}</a>
<a name="ln97"> </a>
<a name="ln98">	if ((disk = fopen(diskname, &quot;r+b&quot;)) == NULL)	// Open for read/write in binary mode</a>
<a name="ln99">	{</a>
<a name="ln100">		printf(&quot;Error: Unable to open disk '%s'\n&quot;, diskname);</a>
<a name="ln101">		exit(0);</a>
<a name="ln102">	}</a>
<a name="ln103">	else	// Opened ok, is it a valid BMFS disk?</a>
<a name="ln104">	{</a>
<a name="ln105">		fseek(disk, 0, SEEK_END);</a>
<a name="ln106">		disksize = ftell(disk) / 1048576;			// Disk size in MiB</a>
<a name="ln107">		fseek(disk, 1024, SEEK_SET);				// Seek 1KiB in for disk information</a>
<a name="ln108">		fread(DiskInfo, 512, 1, disk);				// Read 512 bytes to the DiskInfo buffer</a>
<a name="ln109">		fseek(disk, 4096, SEEK_SET);				// Seek 4KiB in for directory</a>
<a name="ln110">		fread(Directory, 4096, 1, disk);			// Read 4096 bytes to the Directory buffer</a>
<a name="ln111">		rewind(disk);</a>
<a name="ln112">		</a>
<a name="ln113">		if (strcasecmp(DiskInfo, fs_tag) != 0)		// Is it a BMFS formatted disk?</a>
<a name="ln114">		{</a>
<a name="ln115">			if (strcasecmp(s_format, command) == 0)</a>
<a name="ln116">			{</a>
<a name="ln117">				format();</a>
<a name="ln118">			}</a>
<a name="ln119">			else</a>
<a name="ln120">			{</a>
<a name="ln121">				printf(&quot;Error: Not a valid BMFS drive (Disk is not BMFS formatted).\n&quot;);</a>
<a name="ln122">			}</a>
<a name="ln123">			fclose(disk);</a>
<a name="ln124">			return 0;</a>
<a name="ln125">		}</a>
<a name="ln126">	}</a>
<a name="ln127"> </a>
<a name="ln128">	if (strcasecmp(s_list, command) == 0)</a>
<a name="ln129">	{</a>
<a name="ln130">		list();</a>
<a name="ln131">	}</a>
<a name="ln132">	else if (strcasecmp(s_format, command) == 0)</a>
<a name="ln133">	{</a>
<a name="ln134">		if (argc &gt; 3)</a>
<a name="ln135">		{</a>
<a name="ln136">			if (strcasecmp(argv[3], &quot;/FORCE&quot;) == 0)</a>
<a name="ln137">			{</a>
<a name="ln138">				format();</a>
<a name="ln139">			}</a>
<a name="ln140">			else</a>
<a name="ln141">			{</a>
<a name="ln142">				printf(&quot;Format aborted!\n&quot;);</a>
<a name="ln143">			}</a>
<a name="ln144">		}</a>
<a name="ln145">		else	</a>
<a name="ln146">		{</a>
<a name="ln147">			printf(&quot;Format aborted!\n&quot;);</a>
<a name="ln148">		}</a>
<a name="ln149">	}</a>
<a name="ln150">	else if (strcasecmp(s_create, command) == 0)</a>
<a name="ln151">	{</a>
<a name="ln152">		if (filename == NULL)</a>
<a name="ln153">		{</a>
<a name="ln154">			printf(&quot;Error: File name not specified.\n&quot;);</a>
<a name="ln155">		}</a>
<a name="ln156">		else</a>
<a name="ln157">		{</a>
<a name="ln158">			if (argc &gt; 4)</a>
<a name="ln159">			{</a>
<a name="ln160">				int filesize = atoi(argv[4]);</a>
<a name="ln161">				if (filesize &gt;= 1)</a>
<a name="ln162">				{</a>
<a name="ln163">					create(filename, filesize);</a>
<a name="ln164">				}</a>
<a name="ln165">				else</a>
<a name="ln166">				{</a>
<a name="ln167">			  		printf(&quot;Error: Invalid file size.\n&quot;);</a>
<a name="ln168">				}</a>
<a name="ln169">			}</a>
<a name="ln170">			else</a>
<a name="ln171">			{</a>
<a name="ln172">				printf(&quot;Maximum file size in MiB: &quot;);</a>
<a name="ln173">				fgets(tempstring, 32, stdin);			// Get up to 32 chars from the keyboard</a>
<a name="ln174">				filesize = atoi(tempstring);</a>
<a name="ln175">				if (filesize &gt;= 1)</a>
<a name="ln176">					create(filename, filesize);</a>
<a name="ln177">				else</a>
<a name="ln178">					printf(&quot;Error: Invalid file size.\n&quot;);</a>
<a name="ln179">			}</a>
<a name="ln180">		}</a>
<a name="ln181">	}</a>
<a name="ln182">	else if (strcasecmp(s_read, command) == 0)</a>
<a name="ln183">	{</a>
<a name="ln184">		read(filename);</a>
<a name="ln185">	}</a>
<a name="ln186">	else if (strcasecmp(s_write, command) == 0)</a>
<a name="ln187">	{</a>
<a name="ln188">		write(filename);</a>
<a name="ln189">	}</a>
<a name="ln190">	else if (strcasecmp(s_delete, command) == 0)</a>
<a name="ln191">	{</a>
<a name="ln192">		delete(filename);</a>
<a name="ln193">	}</a>
<a name="ln194">	else</a>
<a name="ln195">	{</a>
<a name="ln196">		printf(&quot;Unknown command\n&quot;);</a>
<a name="ln197">	}</a>
<a name="ln198">	if (disk != NULL)</a>
<a name="ln199">	{</a>
<a name="ln200">		fclose( disk );</a>
<a name="ln201">		disk = NULL;</a>
<a name="ln202">	}</a>
<a name="ln203">	return 0;</a>
<a name="ln204">}</a>
<a name="ln205"> </a>
<a name="ln206"> </a>
<a name="ln207">int findfile(char *filename, struct BMFSEntry *fileentry, int *entrynumber)</a>
<a name="ln208">{</a>
<a name="ln209">	int tint;</a>
<a name="ln210"> </a>
<a name="ln211">	for (tint = 0; tint &lt; 64; tint++)</a>
<a name="ln212">	{</a>
<a name="ln213">		memcpy(pentry, Directory+(tint*64), 64);</a>
<a name="ln214">		if (entry.FileName[0] == 0x00)				// End of directory</a>
<a name="ln215">		{</a>
<a name="ln216">			tint = 64;</a>
<a name="ln217">		}</a>
<a name="ln218">		else if (entry.FileName[0] == 0x01)			// Emtpy entry</a>
<a name="ln219">		{</a>
<a name="ln220">			// Ignore</a>
<a name="ln221">		}</a>
<a name="ln222">		else										// Valid entry</a>
<a name="ln223">		{</a>
<a name="ln224">			if (strcmp(filename, entry.FileName) == 0)</a>
<a name="ln225">			{</a>
<a name="ln226">				memcpy(fileentry, pentry, 64);</a>
<a name="ln227">				*entrynumber = tint;</a>
<a name="ln228">				return 1;</a>
<a name="ln229">			}</a>
<a name="ln230">		}	</a>
<a name="ln231">	}</a>
<a name="ln232">	return 0;</a>
<a name="ln233">}</a>
<a name="ln234"> </a>
<a name="ln235"> </a>
<a name="ln236">void list()</a>
<a name="ln237">{</a>
<a name="ln238">	int tint;</a>
<a name="ln239"> </a>
<a name="ln240">	printf(&quot;%s\nDisk Size: %d MiB\n&quot;, diskname, disksize);</a>
<a name="ln241">	printf(&quot;Name                            |            Size (B)|      Reserved (MiB)\n&quot;);</a>
<a name="ln242">	printf(&quot;==========================================================================\n&quot;);</a>
<a name="ln243">	for (tint = 0; tint &lt; 64; tint++)			// Max 64 entries</a>
<a name="ln244">	{</a>
<a name="ln245">		memcpy(pentry, Directory+(tint*64), 64);</a>
<a name="ln246">		if (entry.FileName[0] == 0x00)				// End of directory, bail out</a>
<a name="ln247">		{</a>
<a name="ln248">			tint = 64;</a>
<a name="ln249">		}</a>
<a name="ln250">		else if (entry.FileName[0] == 0x01)			// Emtpy entry</a>
<a name="ln251">		{</a>
<a name="ln252">			// Ignore</a>
<a name="ln253">		}</a>
<a name="ln254">		else										// Valid entry</a>
<a name="ln255">		{</a>
<a name="ln256">			printf(&quot;%-32s %20lld %20lld\n&quot;, entry.FileName, entry.FileSize, (entry.ReservedBlocks*2));</a>
<a name="ln257">		}</a>
<a name="ln258">	}</a>
<a name="ln259">}</a>
<a name="ln260"> </a>
<a name="ln261"> </a>
<a name="ln262">void format()</a>
<a name="ln263">{</a>
<a name="ln264">	memset(DiskInfo, 0, 512);</a>
<a name="ln265">	memset(Directory, 0, 4096);</a>
<a name="ln266">	memcpy(DiskInfo, fs_tag, 4);				// Add the 'BMFS' tag</a>
<a name="ln267">	fseek(disk, 1024, SEEK_SET);				// Seek 1KiB in for disk information</a>
<a name="ln268">	fwrite(DiskInfo, 512, 1, disk);			// Write 512 bytes for the DiskInfo</a>
<a name="ln269">	fseek(disk, 4096, SEEK_SET);				// Seek 4KiB in for directory</a>
<a name="ln270">	fwrite(Directory, 4096, 1, disk);		// Write 4096 bytes for the Directory</a>
<a name="ln271">	printf(&quot;Format complete.\n&quot;);</a>
<a name="ln272">}</a>
<a name="ln273"> </a>
<a name="ln274"> </a>
<a name="ln275">int initialize(char *diskname, char *size, char *mbr, char *boot, char *kernel)</a>
<a name="ln276">{</a>
<a name="ln277">	unsigned long long diskSize = 0;</a>
<a name="ln278">	unsigned long long writeSize = 0;</a>
<a name="ln279">	const char *bootFileType = NULL;</a>
<a name="ln280">	size_t bufferSize = 50 * 1024;</a>
<a name="ln281">	char * buffer = NULL;</a>
<a name="ln282">	FILE *mbrFile = NULL;</a>
<a name="ln283">	FILE *bootFile = NULL;</a>
<a name="ln284">	FILE *kernelFile = NULL;</a>
<a name="ln285">	int diskSizeFactor = 0;</a>
<a name="ln286">	size_t chunkSize = 0;</a>
<a name="ln287">	int ret = 0;</a>
<a name="ln288">	size_t i;</a>
<a name="ln289"> </a>
<a name="ln290">	// Determine how the second file will be described in output messages.</a>
<a name="ln291">	// If a kernel file is specified too, then assume the second file is the</a>
<a name="ln292">	// boot loader.  If no kernel file is specified, assume the boot loader</a>
<a name="ln293">	// and kernel are combined into one system file.</a>
<a name="ln294">	if (boot != NULL)</a>
<a name="ln295">	{</a>
<a name="ln296">		bootFileType = &quot;boot loader&quot;;</a>
<a name="ln297">		if (kernel == NULL)</a>
<a name="ln298">		{</a>
<a name="ln299">			bootFileType = &quot;system&quot;;</a>
<a name="ln300">		}</a>
<a name="ln301">	}</a>
<a name="ln302"> </a>
<a name="ln303">	// Validate the disk size string and convert it to an integer value.</a>
<a name="ln304">	for (i = 0; size[i] != '\0' &amp;&amp; ret == 0; ++i)</a>
<a name="ln305">	{</a>
<a name="ln306">		char ch = size[i];</a>
<a name="ln307">		if (isdigit(ch))</a>
<a name="ln308">		{</a>
<a name="ln309">			unsigned int n = ch - '0';</a>
<a name="ln310">			if (diskSize * 10 &gt; diskSize ) // Make sure we don't overflow</a>
<a name="ln311">			{</a>
<a name="ln312">				diskSize *= 10;</a>
<a name="ln313">				diskSize += n;</a>
<a name="ln314">			}</a>
<a name="ln315">			else if (diskSize == 0) // First loop iteration</a>
<a name="ln316">			{</a>
<a name="ln317">				diskSize += n;</a>
<a name="ln318">			}</a>
<a name="ln319">			else</a>
<a name="ln320">			{</a>
<a name="ln321">				printf(&quot;Error: Disk size is too large\n&quot;);</a>
<a name="ln322">				ret = 1;</a>
<a name="ln323">			}</a>
<a name="ln324">		}</a>
<a name="ln325">		else if (i == 0) // No digits specified</a>
<a name="ln326">		{</a>
<a name="ln327">			printf(&quot;Error: A numeric disk size must be specified\n&quot;);</a>
<a name="ln328">			ret = 1;</a>
<a name="ln329">		}</a>
<a name="ln330">		else</a>
<a name="ln331">		{</a>
<a name="ln332">			switch (toupper(ch))</a>
<a name="ln333">			{</a>
<a name="ln334">					case 'K':</a>
<a name="ln335">						diskSizeFactor = 1;</a>
<a name="ln336">						break;</a>
<a name="ln337">					case 'M':</a>
<a name="ln338">						diskSizeFactor = 2;</a>
<a name="ln339">						break;</a>
<a name="ln340">					case 'G':</a>
<a name="ln341">						diskSizeFactor = 3;</a>
<a name="ln342">						break;</a>
<a name="ln343">					case 'T':</a>
<a name="ln344">						diskSizeFactor = 4;</a>
<a name="ln345">						break;</a>
<a name="ln346">					case 'P':</a>
<a name="ln347">						diskSizeFactor = 5;</a>
<a name="ln348">						break;</a>
<a name="ln349">					default:</a>
<a name="ln350">						printf(&quot;Error: Invalid disk size string: '%s'\n&quot;, size);</a>
<a name="ln351">						ret = 1;</a>
<a name="ln352">						break;</a>
<a name="ln353">			}</a>
<a name="ln354"> </a>
<a name="ln355">			// If this character is a valid unit indicator, but is not at the</a>
<a name="ln356">			// end of the string, then the string is invalid.</a>
<a name="ln357">			if (ret == 0 &amp;&amp; size[i+1] != '\0')</a>
<a name="ln358">			{</a>
<a name="ln359">				printf(&quot;Error: Invalid disk size string: '%s'\n&quot;, size);</a>
<a name="ln360">				ret = 1;</a>
<a name="ln361">			}</a>
<a name="ln362">		}</a>
<a name="ln363">	}</a>
<a name="ln364"> </a>
<a name="ln365">	// Adjust the disk size if a unit indicator was given.  Note that an</a>
<a name="ln366">	// input of something like &quot;0&quot; or &quot;0K&quot; will get past the checks above.</a>
<a name="ln367">	if (ret == 0 &amp;&amp; diskSize &gt; 0 &amp;&amp; diskSizeFactor &gt; 0)</a>
<a name="ln368">	{</a>
<a name="ln369">		while (diskSizeFactor--)</a>
<a name="ln370">		{</a>
<a name="ln371">			if (diskSize * 1024 &gt; diskSize ) // Make sure we don't overflow</a>
<a name="ln372">			{</a>
<a name="ln373">				diskSize *= 1024;</a>
<a name="ln374">			}</a>
<a name="ln375">			else</a>
<a name="ln376">			{</a>
<a name="ln377">				printf(&quot;Error: Disk size is too large\n&quot;);</a>
<a name="ln378">				ret = 1;</a>
<a name="ln379">			}</a>
<a name="ln380">		}</a>
<a name="ln381">	}</a>
<a name="ln382"> </a>
<a name="ln383">	// Make sure the disk size is large enough.</a>
<a name="ln384">	if (ret == 0)</a>
<a name="ln385">	{</a>
<a name="ln386">		if (diskSize &lt; minimumDiskSize)</a>
<a name="ln387">		{</a>
<a name="ln388">			printf( &quot;Error: Disk size must be at least %llu bytes (%lluMiB)\n&quot;, minimumDiskSize, minimumDiskSize / (1024*1024));</a>
<a name="ln389">			ret = 1;</a>
<a name="ln390">		}</a>
<a name="ln391">	}</a>
<a name="ln392"> </a>
<a name="ln393">	// Open the Master boot Record file for reading.</a>
<a name="ln394">	if (ret == 0 &amp;&amp; mbr != NULL)</a>
<a name="ln395">	{</a>
<a name="ln396">		mbrFile = fopen(mbr, &quot;rb&quot;);</a>
<a name="ln397">		if (mbrFile == NULL )</a>
<a name="ln398">		{</a>
<a name="ln399">			printf(&quot;Error: Unable to open MBR file '%s'\n&quot;, mbr);</a>
<a name="ln400">			ret = 1;</a>
<a name="ln401">		}</a>
<a name="ln402">	}</a>
<a name="ln403"> </a>
<a name="ln404">	// Open the boot loader file for reading.</a>
<a name="ln405">	if (ret == 0 &amp;&amp; boot != NULL)</a>
<a name="ln406">	{</a>
<a name="ln407">		bootFile = fopen(boot, &quot;rb&quot;);</a>
<a name="ln408">		if (bootFile == NULL )</a>
<a name="ln409">		{</a>
<a name="ln410">			printf(&quot;Error: Unable to open %s file '%s'\n&quot;, bootFileType, boot);</a>
<a name="ln411">			ret = 1;</a>
<a name="ln412">		}</a>
<a name="ln413">	}</a>
<a name="ln414"> </a>
<a name="ln415">	// Open the kernel file for reading.</a>
<a name="ln416">	if (ret == 0 &amp;&amp; kernel != NULL)</a>
<a name="ln417">	{</a>
<a name="ln418">		kernelFile = fopen(kernel, &quot;rb&quot;);</a>
<a name="ln419">		if (kernelFile == NULL )</a>
<a name="ln420">		{</a>
<a name="ln421">			printf(&quot;Error: Unable to open kernel file '%s'\n&quot;, kernel);</a>
<a name="ln422">			ret = 1;</a>
<a name="ln423">		}</a>
<a name="ln424">	}</a>
<a name="ln425"> </a>
<a name="ln426">	// Allocate buffer to use for filling the disk image with zeros.</a>
<a name="ln427">	if (ret == 0)</a>
<a name="ln428">	{</a>
<a name="ln429">		buffer = (char *) malloc(bufferSize);</a>
<a name="ln430">		if (buffer == NULL)</a>
<a name="ln431">		{</a>
<a name="ln432">			printf(&quot;Error: Failed to allocate buffer\n&quot;);</a>
<a name="ln433">			ret = 1;</a>
<a name="ln434">		}</a>
<a name="ln435">	}</a>
<a name="ln436"> </a>
<a name="ln437">	// Open the disk image file for writing.  This will truncate the disk file</a>
<a name="ln438">	// if it already exists, so we should do this only after we're ready to</a>
<a name="ln439">	// actually write to the file.</a>
<a name="ln440">	if (ret == 0)</a>
<a name="ln441">	{</a>
<a name="ln442">		disk = fopen(diskname, &quot;wb&quot;);</a>
<a name="ln443">		if (disk == NULL)</a>
<a name="ln444">		{</a>
<a name="ln445">			printf(&quot;Error: Unable to open disk '%s'\n&quot;, diskname);</a>
<a name="ln446">			ret = 1;</a>
<a name="ln447">		}</a>
<a name="ln448">	}</a>
<a name="ln449"> </a>
<a name="ln450">	// Fill the disk image with zeros.</a>
<a name="ln451">	if (ret == 0)</a>
<a name="ln452">	{</a>
<a name="ln453">		double percent;</a>
<a name="ln454">		memset(buffer, 0, bufferSize);</a>
<a name="ln455">		writeSize = 0;</a>
<a name="ln456">		while (writeSize &lt; diskSize)</a>
<a name="ln457">		{</a>
<a name="ln458">			percent = writeSize;</a>
<a name="ln459">			percent /= diskSize;</a>
<a name="ln460">			percent *= 100;</a>
<a name="ln461">			printf(&quot;Formatting disk: %llu of %llu bytes (%.0f%%)...\r&quot;, writeSize, diskSize, percent);</a>
<a name="ln462">			chunkSize = bufferSize;</a>
<a name="ln463">			if (chunkSize &gt; diskSize - writeSize)</a>
<a name="ln464">			{</a>
<a name="ln465">				chunkSize = diskSize - writeSize;</a>
<a name="ln466">			}</a>
<a name="ln467">			if (fwrite(buffer, chunkSize, 1, disk) != 1)</a>
<a name="ln468">			{</a>
<a name="ln469">				printf(&quot;Error: Failed to write disk '%s'\n&quot;, diskname);</a>
<a name="ln470">				ret = 1;</a>
<a name="ln471">				break;</a>
<a name="ln472">			}</a>
<a name="ln473">			writeSize += chunkSize;</a>
<a name="ln474">		}</a>
<a name="ln475">		if (ret == 0)</a>
<a name="ln476">		{</a>
<a name="ln477">			printf(&quot;Formatting disk: %llu of %llu bytes (100%%)%9s\n&quot;, writeSize, diskSize, &quot;&quot;);</a>
<a name="ln478">		}</a>
<a name="ln479">	}</a>
<a name="ln480"> </a>
<a name="ln481">	// Format the disk.</a>
<a name="ln482">	if (ret == 0)</a>
<a name="ln483">	{</a>
<a name="ln484">		rewind(disk);</a>
<a name="ln485">		format();</a>
<a name="ln486">	}</a>
<a name="ln487"> </a>
<a name="ln488">	// Write the master boot record if it was specified by the caller.</a>
<a name="ln489">	if (ret == 0 &amp;&amp; mbrFile !=NULL)</a>
<a name="ln490">	{</a>
<a name="ln491">		printf(&quot;Writing master boot record.\n&quot;);</a>
<a name="ln492">		fseek(disk, 0, SEEK_SET);</a>
<a name="ln493">		if (fread(buffer, 512, 1, mbrFile) == 1)</a>
<a name="ln494">		{</a>
<a name="ln495">			if (fwrite(buffer, 512, 1, disk) != 1)</a>
<a name="ln496">			{</a>
<a name="ln497">				printf(&quot;Error: Failed to write disk '%s'\n&quot;, diskname);</a>
<a name="ln498">				ret = 1;</a>
<a name="ln499">			}</a>
<a name="ln500">		}</a>
<a name="ln501">		else</a>
<a name="ln502">		{</a>
<a name="ln503">			printf(&quot;Error: Failed to read file '%s'\n&quot;, mbr);</a>
<a name="ln504">			ret = 1;</a>
<a name="ln505">		}</a>
<a name="ln506">	}</a>
<a name="ln507"> </a>
<a name="ln508">	// Write the boot loader if it was specified by the caller.</a>
<a name="ln509">	if (ret == 0 &amp;&amp; bootFile !=NULL)</a>
<a name="ln510">	{</a>
<a name="ln511">		printf(&quot;Writing %s file.\n&quot;, bootFileType);</a>
<a name="ln512">		fseek(disk, 8192, SEEK_SET);</a>
<a name="ln513">		for (;;)</a>
<a name="ln514">		{</a>
<a name="ln515">			chunkSize = fread( buffer, 1, bufferSize, bootFile);</a>
<a name="ln516">			if (chunkSize &gt; 0)</a>
<a name="ln517">			{</a>
<a name="ln518">				if (fwrite(buffer, chunkSize, 1, disk) != 1)</a>
<a name="ln519">				{</a>
<a name="ln520">					printf(&quot;Error: Failed to write disk '%s'\n&quot;, diskname);</a>
<a name="ln521">					ret = 1;</a>
<a name="ln522">				}</a>
<a name="ln523">			}</a>
<a name="ln524">			else</a>
<a name="ln525">			{</a>
<a name="ln526">				if (ferror(disk))</a>
<a name="ln527">				{</a>
<a name="ln528">					printf(&quot;Error: Failed to read file '%s'\n&quot;, boot);</a>
<a name="ln529">					ret = 1;</a>
<a name="ln530">				}</a>
<a name="ln531">				break;</a>
<a name="ln532">			}</a>
<a name="ln533">		}</a>
<a name="ln534">	}</a>
<a name="ln535"> </a>
<a name="ln536">	// Write the kernel if it was specified by the caller. The kernel must</a>
<a name="ln537">	// immediately follow the boot loader on disk (i.e. no seek needed.)</a>
<a name="ln538">	if (ret == 0 &amp;&amp; kernelFile !=NULL)</a>
<a name="ln539">	{</a>
<a name="ln540">		printf(&quot;Writing kernel.\n&quot;);</a>
<a name="ln541">		for (;;)</a>
<a name="ln542">		{</a>
<a name="ln543">			chunkSize = fread( buffer, 1, bufferSize, kernelFile);</a>
<a name="ln544">			if (chunkSize &gt; 0)</a>
<a name="ln545">			{</a>
<a name="ln546">				if (fwrite(buffer, chunkSize, 1, disk) != 1)</a>
<a name="ln547">				{</a>
<a name="ln548">					printf(&quot;Error: Failed to write disk '%s'\n&quot;, diskname);</a>
<a name="ln549">					ret = 1;</a>
<a name="ln550">				}</a>
<a name="ln551">			}</a>
<a name="ln552">			else</a>
<a name="ln553">			{</a>
<a name="ln554">				if (ferror(disk))</a>
<a name="ln555">				{</a>
<a name="ln556">					printf(&quot;Error: Failed to read file '%s'\n&quot;, kernel);</a>
<a name="ln557">					ret = 1;</a>
<a name="ln558">				}</a>
<a name="ln559">				break;</a>
<a name="ln560">			}</a>
<a name="ln561">		}</a>
<a name="ln562">	}</a>
<a name="ln563"> </a>
<a name="ln564">	// Close any files that were opened.</a>
<a name="ln565">	if (mbrFile != NULL)</a>
<a name="ln566">	{</a>
<a name="ln567">		fclose(mbrFile);</a>
<a name="ln568">	}</a>
<a name="ln569">	if (bootFile != NULL)</a>
<a name="ln570">	{</a>
<a name="ln571">		fclose(bootFile);</a>
<a name="ln572">	}</a>
<a name="ln573">	if (kernelFile != NULL)</a>
<a name="ln574">	{</a>
<a name="ln575">		fclose(kernelFile);</a>
<a name="ln576">	}</a>
<a name="ln577">	if (disk != NULL)</a>
<a name="ln578">	{</a>
<a name="ln579">		fclose(disk);</a>
<a name="ln580">		disk = NULL;</a>
<a name="ln581">	}</a>
<a name="ln582"> </a>
<a name="ln583">	// Free the buffer if it was allocated.</a>
<a name="ln584">	if (buffer != NULL)</a>
<a name="ln585">	{</a>
<a name="ln586">		free(buffer);</a>
<a name="ln587">	}</a>
<a name="ln588"> </a>
<a name="ln589">	if (ret == 0)</a>
<a name="ln590">	{</a>
<a name="ln591">		printf(&quot;Disk initialization complete.\n&quot;);</a>
<a name="ln592">	}</a>
<a name="ln593"> </a>
<a name="ln594">	return ret;</a>
<a name="ln595">}</a>
<a name="ln596"> </a>
<a name="ln597"> </a>
<a name="ln598">// helper function for qsort, sorts by StartingBlock field</a>
<a name="ln599">static int StartingBlockCmp(const void *pa, const void *pb)</a>
<a name="ln600">{</a>
<a name="ln601">	struct BMFSEntry *ea = (struct BMFSEntry *)pa;</a>
<a name="ln602">	struct BMFSEntry *eb = (struct BMFSEntry *)pb;</a>
<a name="ln603">	// empty records go to the end</a>
<a name="ln604">	if (ea-&gt;FileName[0] == 0x01)</a>
<a name="ln605">		return 1;</a>
<a name="ln606">	if (eb-&gt;FileName[0] == 0x01)</a>
<a name="ln607">		return -1;</a>
<a name="ln608">	// compare non-empty records by their starting blocks number</a>
<a name="ln609">	return (ea-&gt;StartingBlock - eb-&gt;StartingBlock);</a>
<a name="ln610">}</a>
<a name="ln611"> </a>
<a name="ln612">void create(char *filename, unsigned long long maxsize)</a>
<a name="ln613">{</a>
<a name="ln614">	struct BMFSEntry tempentry;</a>
<a name="ln615">	int slot;</a>
<a name="ln616">	</a>
<a name="ln617">	if (maxsize % 2 != 0)</a>
<a name="ln618">		maxsize++;</a>
<a name="ln619"> </a>
<a name="ln620">	if (findfile(filename, &amp;tempentry, &amp;slot) == 0)</a>
<a name="ln621">	{</a>
<a name="ln622">		unsigned long long blocks_requested = maxsize / 2; // how many blocks to allocate</a>
<a name="ln623">		unsigned long long num_blocks = disksize / 2; // number of blocks in the disk</a>
<a name="ln624">		char dir_copy[4096]; // copy of directory</a>
<a name="ln625">		int num_used_entries = 0; // how many entries of Directory are either used or deleted</a>
<a name="ln626">		int first_free_entry = -1; // where to put new entry</a>
<a name="ln627">		int tint;</a>
<a name="ln628">		struct BMFSEntry *pEntry;</a>
<a name="ln629">		unsigned long long new_file_start = 0;</a>
<a name="ln630">		unsigned long long prev_file_end = 1;</a>
<a name="ln631"> </a>
<a name="ln632">		printf(&quot;Creating new file...\n&quot;);</a>
<a name="ln633"> </a>
<a name="ln634">		// Make a copy of Directory to play with</a>
<a name="ln635">		memcpy(dir_copy, Directory, 4096);</a>
<a name="ln636"> </a>
<a name="ln637">		// Calculate number of files</a>
<a name="ln638">		for (tint = 0; tint &lt; 64; tint++) </a>
<a name="ln639">		{</a>
<a name="ln640">			pEntry = (struct BMFSEntry *)(dir_copy + tint * 64); // points to the current directory entry</a>
<a name="ln641">			if (pEntry-&gt;FileName[0] == 0x00) // end of directory</a>
<a name="ln642">			{</a>
<a name="ln643">				num_used_entries = tint;</a>
<a name="ln644">				if (first_free_entry == -1)</a>
<a name="ln645">					first_free_entry = tint; // there were no unused entires before, will use this one</a>
<a name="ln646">				break;</a>
<a name="ln647">			}</a>
<a name="ln648">			else if (pEntry-&gt;FileName[0] == 0x01) // unused entry</a>
<a name="ln649">			{</a>
<a name="ln650">				if (first_free_entry == -1)</a>
<a name="ln651">					first_free_entry = tint; // will use it for our new file</a>
<a name="ln652">			}</a>
<a name="ln653">		}</a>
<a name="ln654"> </a>
<a name="ln655">		if (first_free_entry == -1)</a>
<a name="ln656">		{</a>
<a name="ln657">			printf(&quot;Cannot create file: no free directory entries.\n&quot;);</a>
<a name="ln658">			return;</a>
<a name="ln659">		}</a>
<a name="ln660"> </a>
<a name="ln661">		// Find an area with enough free blocks</a>
<a name="ln662">		// Sort our copy of the directory by starting block number</a>
<a name="ln663">		qsort(dir_copy, num_used_entries, 64, StartingBlockCmp);</a>
<a name="ln664"> </a>
<a name="ln665">		for (tint = 0; tint &lt; num_used_entries + 1; tint++)</a>
<a name="ln666">		{</a>
<a name="ln667">			// on each iteration of this loop we'll see if a new file can fit</a>
<a name="ln668">			// between the end of the previous file (initially == 1) </a>
<a name="ln669">			// and the beginning of the current file (or the last data block if there are no more files).</a>
<a name="ln670"> </a>
<a name="ln671">			unsigned long long this_file_start;</a>
<a name="ln672">			pEntry = (struct BMFSEntry *)(dir_copy + tint * 64); // points to the current directory entry</a>
<a name="ln673"> </a>
<a name="ln674">			if (tint == num_used_entries || pEntry-&gt;FileName[0] == 0x01) </a>
<a name="ln675">				this_file_start = num_blocks - 1; // index of the last block</a>
<a name="ln676">			else</a>
<a name="ln677">				this_file_start = pEntry-&gt;StartingBlock;</a>
<a name="ln678"> </a>
<a name="ln679">			if (this_file_start - prev_file_end &gt;= blocks_requested) </a>
<a name="ln680">			{ // fits here</a>
<a name="ln681">				new_file_start = prev_file_end;</a>
<a name="ln682">				break;</a>
<a name="ln683">			}</a>
<a name="ln684"> </a>
<a name="ln685">			if (tint &lt; num_used_entries)</a>
<a name="ln686">				prev_file_end = pEntry-&gt;StartingBlock + pEntry-&gt;ReservedBlocks;</a>
<a name="ln687">		}</a>
<a name="ln688"> </a>
<a name="ln689">		if (new_file_start == 0) </a>
<a name="ln690">		{</a>
<a name="ln691">			printf(&quot;Cannot create file of size %lld MiB.\n&quot;, maxsize);</a>
<a name="ln692">			return;</a>
<a name="ln693">		}</a>
<a name="ln694"> </a>
<a name="ln695">		// Add file record to Directory</a>
<a name="ln696">		pEntry = (struct BMFSEntry *)(Directory + first_free_entry * 64);</a>
<a name="ln697">		pEntry-&gt;StartingBlock = new_file_start;</a>
<a name="ln698">		pEntry-&gt;ReservedBlocks = blocks_requested;</a>
<a name="ln699">		pEntry-&gt;FileSize = 0;</a>
<a name="ln700">		strcpy(pEntry-&gt;FileName, filename);</a>
<a name="ln701"> </a>
<a name="ln702">		if (first_free_entry == num_used_entries &amp;&amp; num_used_entries + 1 &lt; 64)</a>
<a name="ln703">		{</a>
<a name="ln704">			// here we used the record that was marked with 0x00, </a>
<a name="ln705">			// so make sure to mark the next record with 0x00 if it exists</a>
<a name="ln706">			pEntry = (struct BMFSEntry *)(Directory + (num_used_entries + 1) * 64);</a>
<a name="ln707">			pEntry-&gt;FileName[0] = 0x00;</a>
<a name="ln708">		}</a>
<a name="ln709"> </a>
<a name="ln710">		// Flush Directory to disk</a>
<a name="ln711">		fseek(disk, 4096, SEEK_SET);				// Seek 4KiB in for directory</a>
<a name="ln712">		fwrite(Directory, 4096, 1, disk);			// Write 4096 bytes for the Directory</a>
<a name="ln713"> </a>
<a name="ln714">//		printf(&quot;Complete: file %s starts at block %lld, directory entry #%d.\n&quot;, filename, new_file_start, first_free_entry);</a>
<a name="ln715">		printf(&quot;Complete\n&quot;);</a>
<a name="ln716">	}</a>
<a name="ln717">	else</a>
<a name="ln718">	{</a>
<a name="ln719">		printf(&quot;Error: File already exists.\n&quot;);</a>
<a name="ln720">	}</a>
<a name="ln721">}</a>
<a name="ln722"> </a>
<a name="ln723"> </a>
<a name="ln724">void read(char *filename)</a>
<a name="ln725">{</a>
<a name="ln726">	struct BMFSEntry tempentry;</a>
<a name="ln727">	FILE *tfile;</a>
<a name="ln728">	int tint, slot;</a>
<a name="ln729"> </a>
<a name="ln730">	if (0 == findfile(filename, &amp;tempentry, &amp;slot))</a>
<a name="ln731">	{</a>
<a name="ln732">		printf(&quot;Error: File not found in BMFS.\n&quot;);</a>
<a name="ln733">	}</a>
<a name="ln734">	else</a>
<a name="ln735">	{</a>
<a name="ln736">		printf(&quot;Reading '%s' from BMFS to local file... &quot;, filename);</a>
<a name="ln737">		if ((tfile = fopen(tempentry.FileName, &quot;wb&quot;)) == NULL)</a>
<a name="ln738">		{</a>
<a name="ln739">			printf(&quot;Error: Could not open local file '%s'\n&quot;, tempentry.FileName);</a>
<a name="ln740">		}</a>
<a name="ln741">		else</a>
<a name="ln742">		{</a>
<a name="ln743">			fseek(disk, tempentry.StartingBlock*2097152, SEEK_SET); // Skip to the starting block in the disk</a>
<a name="ln744">			for (tint=0; tint&lt;tempentry.FileSize; tint++)</a>
<a name="ln745">			{</a>
<a name="ln746">				putc(getc(disk), tfile);			// This is really terrible.</a>
<a name="ln747">				// TODO: Rework with fread and fwrite (ideally with a 2MiB buffer)</a>
<a name="ln748">			}</a>
<a name="ln749">			fclose(tfile);</a>
<a name="ln750">			printf(&quot;Complete\n&quot;);</a>
<a name="ln751">		}</a>
<a name="ln752">	}</a>
<a name="ln753">}</a>
<a name="ln754"> </a>
<a name="ln755"> </a>
<a name="ln756">void write(char *filename)</a>
<a name="ln757">{</a>
<a name="ln758">	struct BMFSEntry tempentry;</a>
<a name="ln759">	FILE *tfile;</a>
<a name="ln760">	int tint, slot;</a>
<a name="ln761">	unsigned long long tempfilesize;</a>
<a name="ln762"> </a>
<a name="ln763">	if (0 == findfile(filename, &amp;tempentry, &amp;slot))</a>
<a name="ln764">	{</a>
<a name="ln765">		printf(&quot;Error: File not found in BMFS. A file entry must first be created.\n&quot;);</a>
<a name="ln766">	}</a>
<a name="ln767">	else</a>
<a name="ln768">	{</a>
<a name="ln769">		printf(&quot;Writing local file '%s' to BMFS... &quot;, filename);</a>
<a name="ln770">		if ((tfile = fopen(filename, &quot;rb&quot;)) == NULL)</a>
<a name="ln771">		{</a>
<a name="ln772">			printf(&quot;Error: Could not open local file '%s'\n&quot;, tempentry.FileName);</a>
<a name="ln773">		}</a>
<a name="ln774">		else</a>
<a name="ln775">		{</a>
<a name="ln776">			// Is there enough room in BMFS?</a>
<a name="ln777">			fseek(tfile, 0, SEEK_END);</a>
<a name="ln778">			tempfilesize = ftell(tfile);</a>
<a name="ln779">			rewind(tfile);</a>
<a name="ln780">			if ((tempentry.ReservedBlocks*2097152) &lt; tempfilesize)</a>
<a name="ln781">			{</a>
<a name="ln782">				printf(&quot;Not enough reserved space in BMFS.\n&quot;);</a>
<a name="ln783">			}</a>
<a name="ln784">			else</a>
<a name="ln785">			{</a>
<a name="ln786">				fseek(disk, tempentry.StartingBlock*2097152, SEEK_SET); // Skip to the starting block in the disk</a>
<a name="ln787">				for (tint=0; tint&lt;tempfilesize; tint++)</a>
<a name="ln788">				{</a>
<a name="ln789">					putc(getc(tfile), disk);			// This is really terrible.</a>
<a name="ln790">					// TODO: Rework with fread and fwrite (ideally with a 2MiB buffer)</a>
<a name="ln791">				}</a>
<a name="ln792">				// Update directory</a>
<a name="ln793">				memcpy(Directory+(slot*64)+48, &amp;tempfilesize, 8);</a>
<a name="ln794">				fseek(disk, 4096, SEEK_SET);				// Seek 4KiB in for directory</a>
<a name="ln795">				fwrite(Directory, 4096, 1, disk);			// Write new directory to disk</a>
<a name="ln796">				printf(&quot;Complete\n&quot;);</a>
<a name="ln797">			}</a>
<a name="ln798">			fclose(tfile);</a>
<a name="ln799">		}</a>
<a name="ln800">	}</a>
<a name="ln801">}</a>
<a name="ln802"> </a>
<a name="ln803"> </a>
<a name="ln804">void delete(char *filename)</a>
<a name="ln805">{</a>
<a name="ln806">	struct BMFSEntry tempentry;</a>
<a name="ln807">	char delmarker = 0x01;</a>
<a name="ln808">	int slot;</a>
<a name="ln809"> </a>
<a name="ln810">	if (0 == findfile(filename, &amp;tempentry, &amp;slot))</a>
<a name="ln811">	{</a>
<a name="ln812">		printf(&quot;Error: File not found in BMFS.\n&quot;);</a>
<a name="ln813">	}</a>
<a name="ln814">	else</a>
<a name="ln815">	{</a>
<a name="ln816">		printf(&quot;Deleting file '%s' from BMFS... &quot;, filename);</a>
<a name="ln817">		// Update directory</a>
<a name="ln818">		memcpy(Directory+(slot*64), &amp;delmarker, 1);</a>
<a name="ln819">		fseek(disk, 4096, SEEK_SET);				// Seek 4KiB in for directory</a>
<a name="ln820">		fwrite(Directory, 4096, 1, disk);			// Write new directory to disk				</a>
<a name="ln821">		printf(&quot;Complete\n&quot;);</a>
<a name="ln822">	}</a>
<a name="ln823">}</a>
<a name="ln824"> </a>
<a name="ln825"> </a>
<a name="ln826">/* EOF */</a>
</code></pre>
<div class="balloon" rel="554"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v595/" target="_blank">V595</a> The 'disk' pointer was utilized before it was verified against nullptr. Check lines: 554, 577.</p></div>
<div class="balloon" rel="640"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1032/" target="_blank">V1032</a> The pointer 'dir_copy' is cast to a more strictly aligned pointer type.</p></div>
<div class="balloon" rel="696"><p><span style="font-size:18px">&uarr;</span> <a href="https://pvs-studio.com/en/docs/warnings/v1032/" target="_blank">V1032</a> The pointer 'Directory' is cast to a more strictly aligned pointer type.</p></div>
<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>